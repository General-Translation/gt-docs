---
title: useDict()
description: API Reference for the useDict hook
---

## Overview

`useDict()` is used to access translations from the [translation dictionary](/docs/next/reference/dictionaries/dictionaries) for client-side components.
It must be used within a component wrapped by a [`<GTProvider>`](/docs/next/api/components/gtprovider).

```jsx
const d = useDict(); // Get the translation function
d('greeting.hello'); // pass the id to get a translation
```

`useDict()` supports:
  * Translation of string and jsx content.
  * Variable insertion and conditional logic within translations.
  * Optional id prefixing.

For server-side translations, see [`getDict()`](/docs/next/api/dictionary/getDict).

<Callout>
  `getDict()` and `useDict()` use a [dictionary](/docs/next/reference/dictionaries/dictionaries) to store all content for translation.
  This is different from using the [`<T>` component](/docs/next/reference/t-reference) for translation.
  If you are interested in only using `<T>` components for translation, then this document is not relevant.
</Callout>

## Reference

### Parameters

<TypeTable
  type={{
    "id?": {
        type: 'string',
        optional: true,
        default: 'undefined',
    },
  }}
/>

### Description

| Prop | Description |
| ---- | ----------- |
| `id` | An optional prefix to prepend to all translation keys. This is useful for working with nested dictionary values.|

### Returns

A translation function `d` with the following signature:

```jsx
(key: string) => React.ReactNode
```
- `key`: The identifier of the translation to fetch.
- Returns: The translated value as a `React.ReactNode`.

---

## Examples

### Basic Usages
Every entry in your dictionary gets translated.
Entries can be either JSX or a string.

```jsx title="dictionary.jsx" copy
const dictionary = {
  greeting1: <>Hello, Alice</>, // [!code highlight]
  greeting2: "Hello, Bob", // [!code highlight]
};
export default dictionary;
```

When we want to access these entries (on the client side), we call `useDict()`.
This returns a function that accepts the key of a translation from the dictionary.

```jsx title="translateGreeting.jsx" copy
"use client";
import { useDict } from 'gt-next/client';

export default async function translateGreeting() {
  const d = useDict(); // [!code highlight]
  return (
    <p>
      {d('greeting1')} // [!code highlight]
      {d('greeting2')} // [!code highlight]
    </p>
  );
}
```

### Using variables

You can pass variables to dictionary translations.
For jsx content, just use a [variable component](/docs/next/reference/dictionaries/variable-components).
For string content, add curley braces `{}` to the string.

<Callout type="error">
  Whenever you have a variable in your jsx translations,
  NEVER insert variables directly into the jsx.
  ALWAYS use a [variable component](/docs/next/reference/dictionaries/variable-components#motive):
  `<Currency>`, `<DateTime>`, `<Num>`, or `<Var>`.
</Callout>

In order to pass values, you must (1) assign an identifier and (2) reference the identifier when calling the `d()` function.
In this example, we use `<Var>` and `{}` to pass variables to the translations.
In the dictionary, we assign identifiers `name="userName"` and `{userName}`.

```jsx title="dictionary.jsx" copy
const dictionary = {
  greeting1: <>Hello, <Var name="userName"/> !</>, // [!code highlight]
  greeting2: "Hello, {userName}!", // [!code highlight]
};
export default dictionary;
```
In the component, we pass the values `userName: "Alice"` and `userName: "Bob"`.

```jsx title="translateGreeting.jsx" copy
"use client";
import { useDict } from 'gt-next/client';

export default async function translateGreeting() {
  const d = useDict();
  
  // Hello Alice!
  const greetingAlice = d('greeting1', { userName: "Alice" }); // [!code highlight]
  // Hello Bob!
  const greetingBob = d('greeting2', { userName: "Bob" }); // [!code highlight]

  return (
    <p>
      {greetingAlice}
      {greetingBob}
    </p>
  );
}
```

### Using branches
[Branching components](/docs/next/reference/dictionaries/branching-components), such as [`<Branch>`](/docs/next/api/components/branch) and [`<Plural>`](/docs/next/api/components/plural),
can be used to handle control logic in a translation.

In order to pass values, you must (1) assign an identifier and (2) reference the identifier when calling the `d()` function.
In this example, we see that `hairColor` is passed to both `<Branch>` and `<Var>` components.
```jsx title="dictionary.jsx" copy
import { Branch, Var } from 'gt-next';

const dictionary = {
  hairColor: <>
    <Branch name="hairColor" // [!code highlight]
      black={<>Their hair is dark.</>}
      brown={<>Their hair is in the middle.</>}
      blonde={<>Their hair is light.</>}
      >
        {/* fallback incase no branch is matched */}
        <p>Unhandled hair color: <Var name="hairColor"/></p> // [!code highlight]
      </Branch>
  </>,
};
```

```jsx title="HairColor.jsx" copy
"use client";
import { useDict } from 'gt-next/client';

export default function HairColor() {
  const d = useDict();
  return (
    <div>
      { d('hairColor', { hairColor: 'brown' }) } // [!code highlight]
    </div>
  );
}
```

### Using prefixes

We can use prefixes to only translate a subset of the dictionary.
```jsx  title="dictionary.jsx" copy
const dictionary = {
  prefix1: { // [!code highlight]
    prefix2: { // [!code highlight]
      greeting1: <>Hello, Alice</>,
      greeting2: "Hello, Bob",
    }
  }
};
export default dictionary;
```
Because we added the value `'prefix1.prefix2'` to the `useDict` hook, all of the keys are prefixed with `prefix1.prefix2`:
```jsx title="UserDetails.jsx" copy
"use client";
import { useDict } from 'gt-next';

export default function UserDetails() {
  const d = useDict('prefix1.prefix2'); // [!code highlight]
  return (
    <div>
      <p>{d('greeting1')}</p> {/* greeting1 => prefix1.prefix2.greeting1 */} // [!code highlight]
      <p>{d('greeting2')}</p> {/* greeting2 => prefix1.prefix2.greeting2 */} // [!code highlight]
    </div>
  );
}
```
--- 
## Notes
 * The `useDict()` function allows you to access dictionary translations on the client side.
 * The `useDict()` hook can only be used within a component wrapped by a [`<GTProvider>` component](/docs/next/api/components/gtprovider).
 * Supports dynamic behavior and variable insertion with [Branching](/docs/next/reference/template-dictionaries/branching-components) and [Variable Components](/docs/next/reference/template-dictionaries/variable-components) respectively.

## Next Steps
 * For server-side translations, see [`getDict()`](/docs/next/api/dictionary/getDict).
 * Learn more about using dictionaries in the [dictionaries reference](/docs/next/reference/dictionaries/dictionaries).
 * Enhance server-side locale routing with [i18n Routing](/docs/next/guides/i18n-routing) and locale management with [i18n Configuration](/docs/next/reference/i18n-configuration).